
## Heatmaps

#Primero que nada cargamos todas las librerias necesarias.

library(pheatmap)
library(gplots)
library(tidyverse)
 

#Como veniamos haciendo vamos nuevamente a explorar rapido los datos. Que este igual ya lo conocen.

 
head(mtcars)
 

#Para hacer un heatmap, simplemente usamos la funcion heatmap... y presto

 
heatmap(as.matrix(mtcars))
 

#Pero no se ve lindo como en los papes...

#La razon es que las escalas de cada una de estas variables es muy diferente. 

#Para arreglar esto y que los graficos sean explicativos hay que hacer una transformacion de los datos. 

#Las transformaciones cualquiera sea lo que en principio va a hacer es alterar la escala conservando la variabilidad. 

#En este caso vamos a usar `scale()`

 
df_scale <- scale(mtcars)
head(df)
 
#Que hace `scale()`?
  
?scale
#Pero si ahora hacemos el heatmap...
 
heatmap(df_scale)

 

#En este otro caso vamos a usar `cor()`

 
df_norm <- cor(mtcars)
head(df_norm)
 
#Que hace `cor()`?
  
?cor

#Ahora si hacemos el heatmap
 
heatmap(df_norm, scale = "none")

 

#Los heatmap suelen sacar las partes mas esteticas de nosotros y cuando encontramos algo queremos que se vea bonito. 

#Para eso hay paquetes especificos que nos permiten modificar distintas partes y alinearlo con nuestro criterio esterico.
 
library("RColorBrewer")
col <- colorRampPalette(brewer.pal(10, "RdYlBu"))(256)
heatmap(df_scale, scale = "none", col =  col, 
        RowSideColors = rep(c("blue", "pink"), each = 16),
        ColSideColors = c(rep("purple", 5), rep("orange", 6)))
 

 

library("RColorBrewer")
col <- colorRampPalette(brewer.pal(10, "RdYlBu"))(256)
heatmap(df_norm, scale = "none", col =  col, 
        RowSideColors =  c(rep("purple", 5), rep("orange", 6)),
        ColSideColors = c(rep("purple", 5), rep("orange", 6)))

 

#Un paquete que a mi criterio tiene un lindo criterio estetico es `pheatmap()`, esta basado en `ggplot2` y opera muy bien solito.


 
library("pheatmap")
pheatmap(df_scale)
 

#Por defecto y sin hacer mucho solo una transformación en los datos se puede armar un heatmap muy bonito.

#Algunas de las funciones utiles para analisis exporatorios es el de generar grupos, lo que se llama clustering. 
#Que un poco es la gracia de hacer esto.

 
pheatmap(df_scale, cutree_rows = 4)
 

#Sin embargo a veces pasa que el clustering jerarquico nos puede enmascarar efectos.

#Ir desactivando el clustering puede ser util...

 
pheatmap(df_scale, cutree_rows = 4 ,cluster_cols =  F)

 
pheatmap(df_norm, cutree_rows = 4)


pheatmap(df_norm, cutree_rows = 4, cluster_rows = F)

 

#Otras veces desactivar el clustereo jerarquico no cambia mucho.


## Reduccion dimensional 

#Otra manera util de explorar datos con muchas variables es usar reduccion dimensional.

#Es un concepto teorico medio duro, pero a grandes rasgos trata  de representar  un  conjunto de  datos  en un  sub-espacio  lineal  de dimensionalidad reducida  de forma que  este  aún describe de forma aceptable la varianza de los datos, es decir, que tratamos de encontrar una base lineal que reduzca la dimensionalidad de los datos donde la  cantidad de la varianza sea máxima. En  términos matemáticos, podemos decir que PCA,  intenta  encontrar un mapeado lineal  M entre  dos  espacios de coordenadas tal  que se maximice  la función de coste.

#Para llevarlo a cabo primero vamos a transformar un poco los datos con `prcomp()` 
 
#Asignamos iris a un dataframe (df)
df <- iris
df <- as.data.frame(iris)

row.names(df) <- paste(df$Species, row.names(df), sep="_") 
df$Species <- NULL
head(df)

#Usamos prcomp de principal component analysis 
df_pca <- prcomp(df,scale. = T)
df_out <- as.data.frame(df_pca$x)
df_out$group <- sapply( strsplit(as.character(row.names(df)), "_"), "[[", 1 )
head(df_out)
df_pca <- prcomp(df,scale. = T)
df_out <- as.data.frame(df_pca$x)
df_out$group <- sapply( strsplit(as.character(row.names(df)), "_"), "[[", 1 )
head(df_out)

 

#Esto lo graficamos directamente con `ggplot2()`

 
p<-ggplot(df_out,aes(x=PC1,y=PC2,color=group ))
p<-p+geom_point()
p
 

#Sin embargo, que pasa si usamos los otro componentes no tan principales.

 

p<-ggplot(df_out,aes(x=PC2,y=PC3,color=group ))
p<-p+geom_point()
p
 
#Imprime las varianzas de cada componente principal
screeplot(df_pca)